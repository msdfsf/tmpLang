<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>Language Documentation</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">

    <style>
        
        :root {
            --background: #131010;
            --foreground: #FFF0DC;
            --title: #F0BB78;
            --subtle-foreground: #b8b5b1;
            --tmp-color-1: #7aa5d4;
            --tmp-color-2: #d9a86a;
            --tmp-color-3: #8fbc8f;
        }

        body {
            color: var(--foreground);
            background-color: var(--background);
            font-family: "Roboto", sans-serif;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            font-weight: 300;
        }

        main {
            max-width: 50em;
            padding: 2em 1em;
            margin: 0 auto;
        }

        h1, h2, h3 {
            color: var(--title);
            font-weight: 500;
            line-height: 1.3;
            margin-top: 2.5em;
            margin-bottom: 0.8em;
        }

        h1 { font-size: 2.2em; margin-top: 0; }
        h2 { font-size: 1.8em; }
        h3 { font-size: 1.4em; margin-top: 2em; }

        p {
            margin-top: 0;
            margin-bottom: 1em;
        }

        pre, code {
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        pre {
            border-left: 2px solid var(--tmp-color-3); 
            padding: 10px 10px 10px 15px;
            margin-left: 1em;
            margin-right: 1em;
        }

        code {
            font-size: inherit;
            font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        .note {
            font-style: italic;
            color: var(--subtle-foreground);
            font-size: 0.9em;
            margin-top: -0.5em;
            margin-bottom: 1.5em;
        }

        a {
            color: var(--title);
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }

    </style>

</head>
<body>
    <main>
        <h1>Language Documentation</h1> 

        <section>
            <h2>Introduction</h2>
            <p>This document introduces the basic syntax and semantics of the language. It primarily focuses on how to use the language, rather than the design rationale behind its features.</p>
            
        <section>
            <h2>Hello, World!</h2>
            <p>The language does not require an explicit <code>main</code> function. The program's execution begins at the start of the source file provided to the compiler.</p>
            <p>A simple "Hello, world!" program can be written using a string literal, which implicitly prints its content when used as a statement:</p>
            <pre><code>
"Hello, world!"; // Implicitly prints the string
            </code></pre>
            <p>String literals can also act like basic format strings when followed by arguments, similar to <code>printf</code> in C:</p>
            <pre><code>
"Hello, %s!" "world"; // Prints "Hello, world!"
            </code></pre>
            
            <h3>Compiling and Running</h3>
            <p>Compile a source file (e.g., `hello.txt`) into an executable (`app.exe`):</p>
            <pre><code>
compiler build hello.txt app.exe
            </code></pre>
            <p>Compile and run immediately:</p>
            <pre><code>
compiler run hello.txt
            </code></pre>
            <p>Translate the source file only to the intermediate C code:</p>
            <pre><code>
compiler translate hello.txt
            </code></pre>
        </section>
        
        <section>
            <h2>Character Set</h2>
            <p>Source files are expected to be encoded in UTF-8. This allows the direct use of Unicode characters within the code, including string and character literals.</p> </section>

        <section>
            <h2>Comments</h2>
            <p>Comments are ignored by the compiler. Two forms are available:</p>
            <p>Single-line comments start with <code>//</code>:</p>
            <pre><code>
// This is a single-line comment
            </code></pre> <p>Multi-line comments are enclosed in <code>/{</code> and <code>/}</code> and can be nested:</p>
            <pre><code>
/{
    This is a 
    /{ nested /} 
    multi-line comment.
/}
            </code></pre>
        </section>

        <section>
            <h2>Keywords</h2>
            <p>The following keywords are reserved and cannot be used as identifiers:</p>
            <pre><code>
alloc, as, catch, const, def, embed, error, fcn, for, free, from, import, local, loop, namespace, return, using, while, int, i8, u8, i16, u16, i32, u32, i64, u64, f32, f64
            </code></pre> 
            <p class="note">Other identifiers like type names (<code>i32</code>, <code>u8</code> etc.) and the literal <code>null</code> are predefined but not strictly reserved keywords.</p>
        </section>

        <section>
            <h2>Data Types</h2>
            <h3>Built-in Primitive Types</h3>
            <p>The language provides standard primitive numeric types:</p>
            <pre><code>
// Signed Integers: i8, i16, i32, i64
// Unsigned Integers: u8, u16, u32, u64
// Floating-Point: f32, f64
            </code></pre>
            <p>Variable declaration follows the `TypeName VariableName = Initializer;` pattern:</p>
            <pre><code>
i32 count = -10;
u64 flags = 0;
f64 ratio = 1.23;
            </code></pre>
            <p>Implicit casting between numeric types is generally allowed where reasonable (e.g., integer to float, smaller integer to larger).</p>
            <p>Composite types include pointers (<code>^</code>), arrays (<code>[]</code>), structs (<code>def struct</code>), and unions (<code>def union</code>), described below.</p>
        </section>

        <section>
            <h2>Literals</h2>
            <p>Literals represent fixed values directly in the source code.</p>
            
            <h3>Integer Literals</h3>
            <p>Integers can be written in decimal, hexadecimal (prefix <code>0x</code>), or binary (prefix <code>0b</code>). Underscores (<code>_</code>) can be used as visual separators.</p>
            <pre><code>
i32 decimal_val = 1_000;
u32 hex_val     = 0xFF_00;
u8 binary_val  = 0b1010_0101;
            </code></pre>
            
            <h3>Floating-Point Literals</h3>
            <p>Floating-point literals include a decimal point. A suffix <code>f</code> denotes an <code>f32</code> literal; otherwise, the default is <code>f64</code>.</p>
            <pre><code>
f64 pi = 3.14159;
f32 speed_of_light = 299_792_458f; 
f64 default_float = 1.0; // 1 would also be cast implicitly
            </code></pre> 
            
            <h3>Character Literals</h3>
            <p>Character literals represent a single Unicode code point (which may consist of multiple bytes in UTF-8 encoding) or map directly to small integer values. They are enclosed in single quotes (<code>'</code>).</p>
            <p>The type of the resulting integer value depends on the character itself and the context (e.g., the type of the variable it is assigned to). Standard ASCII characters, common escape sequences (<code>\n</code>, <code>\t</code>, etc.), and hexadecimal escapes (<code>\xNN</code>) are supported and typically fit within an 8-bit type:</p>
            <pre><code>
u8 char_a = 'a';     // Represents the UTF-8/ASCII value of 'a' (0x61)
u8 newline = '\n';   // Represents the newline character (e.g., 0x0A)
u8 hex_char = '\x41'; // Represents the byte value 65 (hex 41, ASCII 'A')
            </code></pre>
            <p>Literals representing Unicode code points that require more than one byte in UTF-8 encoding can also be used, typically requiring a wider integer type to hold the code point's value:</p>
            <pre><code>
u16 char_cz = 'č';  // Represents the Unicode code point for 'č' (e.g., 0x010D)
u32 char_jp = 'は'; // Represents the Unicode code point for 'は' (e.g., 0x306F)
            </code></pre>
            <p>Multi-character literals are permitted and produce an integer value. The character bytes are packed into the integer value, with the first character's byte(s) placed in the higher-order (most significant) positions. This follows a fixed big-endian interpretation. If the character sequence uses fewer bytes than the target integer type, it is padded with leading zero bytes.</p>
            <pre><code>
u32 multi_ascii = 'abcd'; // 0x61626364 (bytes of 'a', 'b', 'c', 'd')
u32 multi_ascii_padded = 'abc'; // 0x00616263

// Example with UTF-8 (bytes C4 8D for 'č', 20 for space):
// Forms the integer 0xC48D2000 (assuming padding to 32 bits)
// Practical use cases for multi-byte characters in multi-character literals might be specific.
u32 multi_utf8 = 'č ';
            </code></pre> 
            <p class="note">Character literals (<code>'...'</code>) produce scalar integer values. For representing sequences of characters as arrays, use string literals (<code>"..."</code>).</p>

            <h3>String Literals</h3>
            <p>String literals represent sequences of characters encoded in UTF-8 and are enclosed in double quotes (<code>"..."</code>). They generally result in arrays.</p>
            <p>By default, a string literal is converted to an array of an integer type (<code>u8</code>, <code>u16</code>, or <code>u32</code>) capable of holding the widest single Unicode code point found within the literal. Each element of the resulting array holds one code point.</p>
            <pre><code>
u8[] ascii_str = "Hello";  // Becomes u8 array, each element holds one ASCII char
u16[] utf8_str = "čau";   // 'č' requires u16/u32, so becomes u16 array (or u32 if needed)
            </code></pre>
            <p class="note">If assigning to an array type with insufficient element size (e.g., assigning `"čau"` to <code>u8[]</code>), a compile error occurs. If assigning to a wider type than necessary (e.g., `"abc"` to <code>u16[]</code>), a warning may be issued.</p>
            <p>To obtain the raw UTF-8 byte sequence of a string literal as a <code>u8</code> array, use the <code>b</code> suffix:</p>
            <pre><code>
u8[] raw_bytes = "čau"b; // Represents the bytes: C4 8D 61 75
            </code></pre> 
        </section>

        <section>
            <h2>Operators</h2>
            <p>Common operators are supported (precedence generally follows C conventions):</p> 
            <pre><code>
// Arithmetic:  + - * / %
// Bitwise:     & | ^ ~ << >>
// Logical:     && || !
// Comparison:  == != < > <= >=
// Member/Scope: . ::
// Pointer:     ^ (type/deref), & (address-of)
// Assignment:  =
// Other:       : (init/slice), .. (concat/range), , (separator)
            </code></pre>
        </section>

        <section>
            <h2>Qualifiers</h2>
            <p><code>embed</code> and <code>const</code> modify declarations:</p>
            <pre><code>
embed i32 COMPILE_TIME_VAL = 10 * (1 + 1); // Have to be computable by compiler
const f64 PI = 3.14159;             // Cannot be modified after initialization
            </code></pre>
            <ul>
                <li><code>embed</code>: Ensures the value is known at compile time. The variable itself may not exist at runtime; its value is embedded directly where used.</li>
                <li><code>const</code>: Makes the variable read-only after initialization.</li>
            </ul>      
        </section>

        <section>
            <h2>Pointers</h2>
            <p>Pointers (<code>^</code>) store memory addresses. <code>^</code> is used for type declaration and dereferencing. <code>&</code> takes the address.</p>
            <pre><code>
i32 value = 42;
i32^ ptr_to_val = &value; // ptr_to_val now holds the address of value
i32^ null_ptr = null;     // Initialize with null

i32 fetched_value = ^ptr_to_val; // Dereference to get 42
            </code></pre>
            <p>Function pointers store the address of a function:</p>
            <pre><code>
fcn add(i32 a, i32 b) -> i32 { return a + b; }
fcn (i32, i32 -> i32) p_add = add; // Declare and assign function pointer
i32 result = p_add(5, 3);          // Call function via pointer (result is 8)
            </code></pre>
        </section>

        <section>
            <h2>Memory Allocation</h2>
            <p>Use <code>alloc</code> to allocate memory dynamically on the heap, returning a pointer. Use <code>free</code> to deallocate.</p>
            <pre><code>
// Allocate space for one int
i32^ p1 = alloc i32; 

// Allocate space for 10 floats
f32^ p2 = alloc f32[10]; 

// Allocate and initialize
i32^ p3 = alloc i32 : 42; 
Point^ p4 = alloc Point : { x: 1, y: 1 }; 

// Type inference from left side
i32^ p5 = alloc : 100; // Allocates int, initializes to 100

free p1; 
free p2; 
// ... free other pointers when done
            </code></pre>
            <p class="note"><code>alloc</code> must appear on the right side of an assignment.</p> <p class="note">The initializer after <code>:</code> must be compatible with the allocated type.</p> </section>

        <section>
            <h2>Arrays</h2>
            <p>Arrays represent a contiguous sequence of elements of the same type. Operations on array variables often apply element-wise (value semantics).</p> <p>Declaration and initialization:</p>
            <pre><code>
// Static array of 4 integers (size known at compile time)
i32[4] static_arr; 

// Initialized static array (length inferred)
i32[] static_init = { 10, 20, 30 }; 

// Initialize all elements to zero
f32[10] zeros = 0.0; 

// Qualifiers apply to elements
const i32[] read_only_arr = { 1, 1, 2, 3 };
embed i32[] compile_time_arr = { 1, 2, 3 };
            </code></pre>
            <p class="note">Declaring an array without an initializer (like <code>static_arr</code> above) leaves its element values undefined.</p>
            
            <p>Access elements by zero-based index:</p>
            <pre><code>
                i32 first = static_init[0]; // 10
            </code></pre>

            <p>Get the number of elements using <code>.length</code>:</p> <pre><code>u64 count = static_init.length; // 3</code></pre>
            <p class="note">When an array is passed to a function, its length is typically passed implicitly alongside the data pointer.</p> <p>Get the total size in bytes using <code>.size</code>:</p> <pre><code>u64 bytes = static_init.size; // sizeof(i32) * 3</code></pre>
            <p class="note"><code>.size</code> is generally calculated as <code>element_type_size * array.length</code>. For array lists, <code>.capacity</code> gives the allocated size.</p> <p>Four main array types exist:</p>
            <pre><code>
// 1. Static: Compile-time fixed size, usually stack/static allocation
Type[N] static_array; 

// 2. Const-Dynamic: Runtime fixed size, heap allocated, length constant after alloc
Type[const] const_dyn_array = alloc Type[runtime_size];

// 3. Dynamic: Runtime variable size (manual reallocation needed), heap allocated
Type[dynamic] dyn_array = alloc Type[runtime_size]; 
// dyn_array might be reassigned to result of another alloc

// 4. Array List (Autonomous): Auto-resizing on write, heap allocated
Type[auton] list = alloc Type[initial_capacity]; 
list[large_index] = value; // May reallocate and grow
u64 cap = list.capacity;   // Get allocated capacity
            </code></pre>

            <p>Concatenate arrays using <code>..</code> (result needs allocation if dynamic):</p>
            <pre><code>
i32[] a = {1, 2};
i32[] b = {3, 4};
i32[const] c = alloc []: a .. b; // c = {1, 2, 3, 4}
            </code></pre>
            
            <h3>Slices</h3>
            <p>Slices provide a way to refer to a contiguous subsequence of an array's elements using the syntax <code>array[start : end]</code> (inclusive). While slices internally reference the original array data (pointer, length, offset), operations involving slices typically exhibit value semantics.</p>
            <p>Creating a slice does not copy data immediately. However, assigning a slice to an array variable copies the referenced elements:</p>
            <pre><code>
i32[] array = { 10, 20, 30, 40, 50 };
// slice_val now contains a copy of { 20, 30, 40 }
i32[] slice_val = array[1 : 3];
            </code></pre> 
            <p>Slices can be used on the left side of an assignment to modify a portion of the original array. The right-hand side expression (which might itself be a slice) is evaluated, and its elements are copied into the memory locations designated by the left-hand slice:</p>
            <pre><code>
i32[] array = { 10, 20, 30, 40, 50 };
i32[] new_data = { 22, 33 };

// Copies elements from new_data into array at indices 1 and 2
array[1 : 2] = new_data; 
// array is now { 10, 22, 33, 40, 50 }

// Copies element from array[4] into array[0]
array[0 : 0] = array[4 : 4]; 
// array is now { 50, 22, 33, 40, 50 }
            </code></pre>
            <p>Slice syntax variants:</p>
            <pre><code>
array[N:]  // Slice from index N to the end
array[:M]  // Slice from the beginning up to index M (inclusive)
array[:]   // Slice representing the entire array
            </code></pre>
            <p class="note">Using slices within dynamic arrays (safety check of static arrays should be provided by compiler) requires careful management, especially when modifying arrays via slice assignments. The length of the right-hand side must match the length implied by the left-hand side slice.</p>
        </section>

        <section>
            <h2>Loops</h2>
            <p>The language provides `for`, `while`, and `loop` constructs.</p>
            <pre><code>
// C-style for loop
for i32 i = 0; i < 10; i = i + 1 { /{ ... /} }

// While loop
i32 count = 5;
while count > 0 { 
    count = count - 1;
    /{ ... /} 
}

// Range-based loop (iterates indices 0 to array.length-1)
i32[] my_array = {10, 20, 30};
loop my_array using i32 idx {
    i32 element = my_array[idx];
    // ... use idx and element
}
            </code></pre>
        </section>

        <section>
            <h2>Enums</h2>
            <p>Enums define named constants, acting like `embed` variables (values must be compile-time known). If a value is omitted, it's assigned sequentially based on the previous value (+1). An underlying integer type can be specified (default depends on values, often `i32`).</p>
            <pre><code>
enum Color : u8 { // Explicit underlying type u8
    RED = 1;
    GREEN;     // Value is 2
    BLUE;      // Value is 3
}

enum Status {   // Implicit underlying type (likely i32)
    OK = 0;
    ERROR = -1;
    PENDING;   // Value is 0 (based on previous ERROR -> -1 + 1 = 0)
    TIMEOUT = 100;
    RETRY;     // Value is 101
}

u8 c = Color.RED; // Access using '.'
            </code></pre> <p class="note">Floating-point or other non-integer values assigned in enums are typically cast to the underlying integer type.</p>
        </section>

        <section>
            <h2>Custom Data Types</h2>
            
            <h3>Structs</h3>
            <p>Structs group multiple data fields of potentially different types under one name. Defined using <code>def</code> (<code>struct</code> keyword optional).</p>
            <pre><code>
def Point { // 'def struct Point' is also valid
    f32 x = 0.0; // Default value
    f32 y = 0.0;
}
            </code></pre>
            <p>Access members using <code>.</code>, which also works for pointers to structs (automatic dereference).</p>
            <pre><code>
Point p1;          // Uses default values { x: 0.0, y: 0.0 }
p1.x = 10.0;

Point^ p_ptr = alloc Point : { 5.0, -5.0 };
p_ptr.y = p_ptr.x; // Access via pointer also uses '.'
            </code></pre> <p>Struct initialization options:</p>
            <pre><code>
// Default initialization (uses default member values if specified)
Point p_default; 

// Empty initializer (leaves members uninitialized, ignoring defaults)
Point p_empty = {}; 

// Ordered initialization (values match declaration order)
Point p_ordered = { 1.0, 2.0 }; 

// Named initialization (order doesn't matter)
Point p_named = { y: 2.0, x: 1.0 };

// Partial named initialization
Point p_partial = { x: 1.0 }; 

// Zero initialization (all members set to zero equivalent)
Point p_zero = 0;

// Rest initialization (only with named initialization)
Point p_rest = { x: 1.0, ...: 0 }; // y becomes 0.0

// Arithmetic on initializers (applies element-wise) (*removed, may return back)
Point p_calc = {1.0, 1.0} + {x: 0.5, y: -0.5} * 2.0; // -> {2.0, 0.0}
            </code></pre>
            <p class="note">Combining ordered and named initializers is disallowed. Arithmetic requires compatible initializers (same fields set or one side is scalar).</p>

            <h3>Unions</h3>
            <p>Unions allow storing different types in the same memory location, but only one type is active at a time. Defined using <code>def union</code>.</p>
            <pre><code>
def union IntOrFloat {
    i32 i;
    f32 f;
}
            </code></pre>
            <p class="note">The language uses C-style (untagged) unions. It is the programmer's responsibility to track which member is currently valid. Accessing the wrong member leads to undefined behavior.</p>
            <pre><code>
IntOrFloat val;
val.i = 10;      // val now holds an integer
f32 num = val.f; // Undefined behavior if i was last written
            </code></pre>
        </section>

        <section>
            <h2>Namespaces</h2>
            <p>Namespaces (<code>namespace Name { ... }</code>) group declarations to avoid name conflicts. Access members using the scope resolution operator (<code>::</code>).</p>
            <pre><code>
namespace Math {
    const PI = 3.14;
    fcn area(f32 radius) -> f32 { /{ ... /} }
}

f32 circ_area = Math::area(5.0);
            </code></pre>
        </section>

        <section>
            <h2>Imports</h2> <p>Code from other files is included using the <code>import</code> keyword. Direct import into the current scope is disallowed; imported content must always be wrapped.</p>
            <p>Import file content into a namespace:</p>
            <pre><code>
import math_utils.vi as namespace Math; 
f32 val = Math::some_function();
            </code></pre>
            <p>Import file content as a function body or into a new scope:</p>
            <pre><code>
import init_script.vi as fcn run_init;
import config_vars.vi as scope; // Executes config_vars.vi code immediately

run_init(); // Call the imported function
            </code></pre>
            <p>Import specific identifiers from a file using <code>from ... import ...</code>:</p>
            <pre><code>
// Import PI and E from constants.vi into namespace Consts
import from constants.vi PI, E as namespace Consts; 

// Import only 'helper_func' into the current scope
import from helpers.vi helper_func;
helper_func();
// or
import from helpers.vi helper_func as namespace Help;
Hlp::helper_func(); 
            </code></pre> <p>Restrict visibility of imported symbols using <code>local</code> (they won't be re-exported if the current file is imported elsewhere):</p>
            <pre><code>
import internal_lib.vi as local namespace Internal;
            </code></pre>
            <p class="note">Import paths are typically relative to the importing file. All imports are processed before other code execution begins, respecting the order of import statements.</p>
        </section>

        <section>
            <h2>Error Handling</h2>
            <p>Errors are represented by unique identifiers grouped into hierarchical error sets, defined using <code>error</code>.</p>
            <pre><code>
error FileError {
    NotFound; // Empty error sets, act as unique IDs
    PermissionDenied;
}
error NetworkError {
    Timeout;
    HostUnreachable;
    Refused;
}
error AppError {
    FileError; // Can include other sets
    NetworkError;
    Database; // Another unique ID
}
            </code></pre>
            <p>Access specific errors using <code>::</code> (e.g., <code>AppError::FileError::NotFound</code>). Assign errors to variables of type <code>error</code>. <code>null</code> represents no error.</p>
            <pre><code>
error current_err = null;
current_err = AppError::Network::Timeout;
            </code></pre>

            <p>Functions declare the potential error set they can return using <code>using</code>:</p>
            <pre><code>
fcn read_config(u8[] path) using FileError -> Config { /{ ... /} }
            </code></pre>

            <p>Return values and errors using <code>return</code>:</p>
            <pre><code>
fcn process() using AppError -> i32 {
    if /{ success /} { return 100; }              // Return value only (error is null)
    if /{ file error /} { return _, AppError::File::NotFound; } // Return error only
    if /{ net error */} { return -1, AppError::Net::Timeout; } // Return value and error
}
            </code></pre>

            <p>Handle potential errors using <code>catch</code>:</p>
            <pre><code>
error err;
i32 result = process() catch err; // Catches error into 'err'

if err != null {
    if err == AppError::FileError::NotFound { /{ handle file not found /} }
    if err == AppError::NetworkError::Timeout { /{ handle timeout /} }
    // ... other checks ...
} else {
    // Use result ...
}
            </code></pre>
            <p>A local scope for the error can be created directly:</p>
            <pre><code>
i32 result = process() catch { // 'err' implicitly declared for this block
    if err != null { 
       /{ handle error /}
    } 
}; // Error variable 'err' does not exist beyond '}'
// Use result if no error occurred and wasn't handled inside block
            </code></pre>
        </section>

        <section>
            <h2>Interoperability (Foreign Functions)</h2> <p>Functions can be written directly in C or potentially other languages if support is defined.</p>
            <p>The <code>C</code> tag is built-in for including C code directly within a function body. The compiler will integrate this C code during the C intermediate language generation phase.</p>
            <pre><code>
// Declare external C function if needed (e.g., from system library)
// extern fcn printf(const u8^ format, ...) -> i32; // Example syntax for extern

// Define a function with a C body
fcn print_hello[C]() {
    // This is standard C code
    #include &lt;stdio.h&gt; // C includes might be needed
    printf("Hello from embedded C!\n");
}

// Call the function
print_hello();
            </code></pre>
            <p class="note">Support for other languages would require defining how the compiler should invoke an external compiler/tool for that language to produce compatible C code or object files.</p> </section>
    </main>
</body>
</html>